# System design — VoiceOps Bridge

## 1) Problem
During incidents, on‑call responders lose time context-switching:
- opening runbooks
- checking dashboards
- drafting stakeholder updates
- creating tickets / tasks

Voice is the fastest interface *when your hands are busy*, but voice agents often:
- hallucinate UI instructions,
- spam tools,
- and fail silently when networks drop.

**VoiceOps Bridge** is a reference architecture + demo app that shows how to integrate a real-time voice agent into a web app *with production-grade guardrails*.

---

## 2) Goals
1. **Real-time voice**: browser-to-agent voice chat with low latency.
2. **Secure auth**: API key stays on the server; clients receive short-lived tokens only.
3. **Agent → UI control**: structured “client actions” to drive the UI (navigate, show checklist, open runbook).
4. **Tooling hooks**: optional MCP integrations for tickets/Slack/etc.
5. **Observability**: session-level correlation across token minting + voice session + logs.
6. **Failure handling**: reconnect, token renewal, graceful degradation.

## 3) Non-goals
- Full incident management product (paging, status pages, etc.)
- Storing secrets in the voice session
- Making destructive changes to production without explicit confirmation

---

## 4) High-level architecture
**Components**
- **Web client**: connects to LiveKit, plays agent audio, publishes/receives data-channel actions.
- **Token proxy (backend)**: mints LiveKit access tokens by calling Vocal Bridge.
- **Vocal Bridge**: provides the deployed voice agent and its configuration (STT/TTS/model settings).
- **LiveKit**: transports audio + data channel over WebRTC.
- **MCP tool layer (optional)**: e.g., Zapier MCP to call downstream apps.
- **Post-processing (optional)**: after-call summarization + workflow execution.

---

## 5) Key flows

### A) Connect flow (secure token minting)
1. Browser calls `GET /api/voice-token`.
2. Backend calls Vocal Bridge `POST /api/v1/token` using `X-API-Key`.
3. Backend returns `{ livekit_url, token, room_name, expires_in, ... }`.
4. Browser connects to LiveKit with those credentials and enables microphone.

### B) Voice session
- Audio: Browser ↔ LiveKit ↔ Agent (bi-directional).
- Data: `topic=client_actions` over LiveKit data channel.

### C) Agent → App “client actions”
Example payload:
```json
{
  "type": "client_action",
  "action": "open_runbook",
  "payload": { "url": "https://example.com/runbook/checkout-5xx" }
}
```
The client validates:
- action name is allowlisted
- payload size is bounded
- destructive actions require user confirmation

### D) App → Agent context updates (optional)
Example:
```json
{
  "type": "client_action",
  "action": "incident_context",
  "payload": { "service": "checkout", "signal": "elevated_5xx" }
}
```
Recommended behavior: **notify** (adds context without forcing a spoken response).

### E) Post-processing (optional)
After the call ends, a post-processing LLM can:
- summarize the transcript
- extract action items
- and call MCP tools (e.g., create Jira ticket, draft Slack update)

---

## 6) Data model (minimal)

### Session
- `session_id` (string; generated by backend or caller)
- `room_name` (LiveKit room)
- `participant_identity` (client identity)
- timestamps: connect/disconnect

### Action event
- `session_id`
- `direction`: `agent_to_app` | `app_to_agent`
- `action` (string)
- `payload` (json)
- `timestamp`

### Call log (platform-provided)
- transcript
- debug events (STT, agent responses, tool calls)
- recordings (if enabled)

---

## 7) Security model
- **Server-only API key**: API key never reaches browsers.
- **Short-lived tokens**: tokens expire; client reconnects via backend.
- **Client action validation**: allowlist + payload bounds + confirmation gates.
- **Least privilege** for MCP tools: separate “read” vs “write” tool sets.

---

## 8) Scale + performance
- Backend is stateless; horizontally scalable.
- Cache policy/metadata locally; do not cache tokens beyond their TTL.
- Use WebRTC transport; avoid adding extra audio hops.

---

## 9) Alternatives considered
- **Direct token minting from browser**: rejected (exposes API key).
- **Text-only**: rejected for incident scenarios where hands-free matters.
- **Unstructured UI commands (“click the red button”)**: rejected; client actions are more reliable.

